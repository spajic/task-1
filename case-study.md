# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику:
* Сначала я написал свой "велосипед", который запускал код несколько раз, измерял время выполнения через `Benchmark.realtime` и считал среднее.
* Но потом я подсмотрел в разборе из второй лекции инструмент `Benchmark.ips` и он мне понравился

В итоге метрика это число итераций в секунду

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста позволяет не допустить изменения логики программы при оптимизации. Но этот тест был на минитесте и я решил переписать его на более привычный мне `RSpec`. В тесте я зафиксиовал что программа возвращает теже результаты и что программа не стала работать медленнее.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за 55 секунд.

Вот как я построил `feedback_loop`:
* Все эталонные файлы лежат папке `spec/fixtures`
* Файлы, которые раньше генерировал минитест теперь называются `data.txt` и `reference_result.json`
* Тест smoke_test_spec.rb проверяет что:
** вывод программы все еще соответствует эталонным файлам
** выполнение программы не стало медленее чем было в начале работы (3.5 секунд в моем случае)
* Скрипт `calc_times.rb` считает метрику запуская `Benchmark.ips` по набору файлов от 100 строк до 5к строк
* Запуск всего Feedback-Loop производится одним скриптом `test-it.sh`

## Фиксируем начальное состояние
До начала всяких оптимизаций наша метрика была вот такой
```
Calculating -------------------------------------
                0.1k    495.917  (±11.1%) i/s -      2.433k in   4.998076s
                0.2k    222.219  (± 9.9%) i/s -      1.096k in   5.001490s
                0.3k    136.152  (± 9.5%) i/s -    673.000  in   5.000267s
                0.4k     93.109  (± 9.7%) i/s -    461.000  in   5.010672s
                0.5k     68.628  (± 7.3%) i/s -    341.000  in   5.010336s
                 01k     25.422  (± 3.9%) i/s -    127.000  in   5.014775s
                 02k      8.279  (± 0.0%) i/s -     42.000  in   5.082306s
                 03k      4.093  (± 0.0%) i/s -     21.000  in   5.134921s
                 04k      2.464  (± 0.0%) i/s -     13.000  in   5.281077s
                 05k      1.658  (± 0.0%) i/s -      9.000  in   5.428681s

Comparison:
                0.1k:      495.9 i/s
                0.2k:      222.2 i/s - 2.23x  slower
                0.3k:      136.2 i/s - 3.64x  slower
                0.4k:       93.1 i/s - 5.33x  slower
                0.5k:       68.6 i/s - 7.23x  slower
                 01k:       25.4 i/s - 19.51x  slower
                 02k:        8.3 i/s - 59.90x  slower
                 03k:        4.1 i/s - 121.17x  slower
                 04k:        2.5 i/s - 201.25x  slower
                 05k:        1.7 i/s - 299.06x  slower
```
То есть при увеличении объема в 50 раз метрика ухужшалась почти в 300 раз

## Вникаем в детали системы, чтобы найти 20% точек роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*

Вот какие проблемы удалось найти и решить

### Ваша находка №1
О вашей находке №1

### Ваша находка №2
О вашей находке №2

### Ваша находка №X
О вашей находке №X

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце*

*Какими ещё результами можете поделиться*

## Защита от регресса производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы сделано *то, что вы для этого сделали*
